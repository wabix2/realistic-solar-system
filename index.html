<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D RK4 N-Body Simulator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            background-color: #1a1a2e; /* Dark space background */
            color: #ffffff;
            font-family: 'Inter', sans-serif;
        }
        #controls {
            width: 300px;
            padding: 20px;
            background-color: #1e1e3f;
            box-shadow: 4px 0 8px rgba(0, 0, 0, 0.6);
            overflow-y: auto;
            border-right: 2px solid #3a3a6e;
        }
        #simCanvas {
            flex-grow: 1;
            cursor: crosshair;
        }
        .control-group {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid #3a3a6e;
            border-radius: 8px;
            background-color: #25254d;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #ffcc00;
        }
        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        input[type="number"] {
            width: calc(100% - 10px);
            padding: 8px;
            background: #3a3a6e;
            border: 1px solid #5a5ac8;
            border-radius: 4px;
            color: white;
        }
        button {
            background-color: #4a4a9e;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            width: 100%;
            font-weight: bold;
        }
        button:hover {
            background-color: #5a5ac8;
            transform: translateY(-1px);
        }
        .info-status p {
            margin: 5px 0;
            font-size: 0.9rem;
            color: #ccc;
        }
    </style>
</head>
<body>

    <!-- Control Panel -->
    <div id="controls">
        <h1 style="color: #00ffaa; font-size: 1.8rem; margin-bottom: 30px; text-align: center;">Orbital Simulator</h1>

        <!-- Body Mass Control -->
        <div class="control-group">
            <label for="massSlider">New Body Mass (M):</label>
            <input type="range" id="massSlider" min="5" max="500" value="50" step="5">
            <p style="text-align: center; margin-top: 10px; color: #ffcc00;"><span id="currentMass">Mass: 50</span></p>
        </div>

        <!-- Gravitational Constant Control -->
        <div class="control-group">
            <label for="gConstant">Gravitational Constant (G):</label>
            <input type="range" id="gConstant" min="10" max="1000" value="500" step="10">
            <p style="text-align: center; margin-top: 10px; color: #ffaa00;"><span id="currentG">G: 500</span></p>
        </div>

        <!-- Time Step Control -->
        <div class="control-group">
            <label for="timeStep">Time Step ($\Delta t$):</label>
            <input type="number" id="timeStep" value="0.01" step="0.001" min="0.001" max="0.1">
        </div>

        <!-- Action Buttons -->
        <div class="control-group">
            <p style="margin-bottom: 15px; font-size: 0.9rem; color: #ccc;">**Creation:** Click and drag on the canvas. Drag distance determines initial velocity (speed).</p>
            <button id="clearButton">Clear All Bodies</button>
        </div>

        <!-- Status Info -->
        <div class="control-group info-status">
            <p style="color: #ffcc00; font-weight: bold; border-bottom: 1px solid #3a3a6e; padding-bottom: 5px;">Status:</p>
            <p>Bodies: <span id="bodyCount">0</span></p>
            <p>FPS: <span id="fpsDisplay">0</span></p>
            <p style="margin-top: 10px; font-size: 0.8rem; color: #999;">Physics Core: RK4 Integration</p>
        </div>
    </div>

    <!-- Canvas -->
    <canvas id="simCanvas"></canvas>

    <!-- Core JavaScript -->
    <script>
        // --- Setup ---
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        let bodies = [];
        let simRunning = true;

        // Display/Input Variables
        let canvasCenter = { x: 0, y: 0 };
        let dragStartPos = null;
        let dragEndPos = null;
        let isDragging = false;
        const trailHistoryLength = 400; // Length of the path trail

        // Get controls from the DOM
        const massSlider = document.getElementById('massSlider');
        const gConstantInput = document.getElementById('gConstant');
        const timeStepInput = document.getElementById('timeStep');
        const currentMassDisplay = document.getElementById('currentMass');
        const currentGDisplay = document.getElementById('currentG');

        // --- Celestial Body Class (2D) ---
        class Body {
            constructor(mass, pos, vel, color = null) {
                this.mass = mass;
                this.pos = { x: pos.x, y: pos.y }; // Position (x, y)
                this.vel = { x: vel.x, y: vel.y }; // Velocity (vx, vy)
                this.acc = { x: 0, y: 0 };         // Initial acceleration is 0, it is calculated by physics loop
                this.radius = Math.cbrt(mass) * 1.5 + 2; // Size proportional to cube root of mass
                this.color = color || '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
                this.trail = [];
            }
        }

        // --- Utility Functions ---

        function resizeCanvas() {
            canvas.width = window.innerWidth - 300; // Subtract control panel width
            canvas.height = window.innerHeight;
            canvasCenter.x = canvas.width / 2;
            canvasCenter.y = canvas.height / 2;
            draw();
        }

        function clearCanvas() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function getDistanceSq(b1, b2) {
            const dx = b2.pos.x - b1.pos.x;
            const dy = b2.pos.y - b1.pos.y;
            return dx * dx + dy * dy;
        }

        function getDirectionVector(b1, b2) {
            return {
                x: b2.pos.x - b1.pos.x,
                y: b2.pos.y - b1.pos.y
            };
        }

        function normalizeVector(v) {
            const magnitude = Math.sqrt(v.x * v.x + v.y * v.y);
            return {
                x: v.x / magnitude,
                y: v.y / magnitude
            };
        }

        // --- PHYSICS CORE: RK4 INTEGRATION ---

        /**
         * Calculates the derivatives (velocities and accelerations) for a set of bodies.
         * The acceleration calculated here is the instantaneous change in velocity (dVel).
         */
        function calculateDerivatives(currentBodies) {
            const G = parseFloat(gConstantInput.value); // Get G dynamically
            
            const derivatives = currentBodies.map(b => ({
                dPos: { x: b.vel.x, y: b.vel.y }, // dPos = Velocity
                dVel: { x: 0, y: 0 }              // dVel = Acceleration (will be calculated)
            }));

            // Calculate accelerations (dv/dt)
            for (let i = 0; i < currentBodies.length; i++) {
                const b_i = currentBodies[i];
                let accX = 0;
                let accY = 0;

                for (let j = 0; j < currentBodies.length; j++) {
                    if (i === j) continue; // Skip self-interaction

                    const b_j = currentBodies[j];
                    const dir = getDirectionVector(b_i, b_j);
                    const r_sq = getDistanceSq(b_i, b_j);

                    // Add a small constant (100) to r_sq to prevent extreme forces when bodies collide
                    const safe_r_sq = Math.max(r_sq, 100); 

                    // a_i = F / m_i = G * m_j / r^2
                    const magnitude = (G * b_j.mass) / safe_r_sq;
                    const unitDir = normalizeVector(dir);

                    accX += magnitude * unitDir.x;
                    accY += magnitude * unitDir.y;
                }
                derivatives[i].dVel.x = accX;
                derivatives[i].dVel.y = accY;
            }
            return derivatives;
        }

        /**
         * Clones the bodies array for use in intermediate RK4 calculations.
         */
        function cloneBodies(sourceBodies) {
            return sourceBodies.map(b => new Body(
                b.mass,
                { x: b.pos.x, y: b.pos.y },
                { x: b.vel.x, y: b.vel.y },
                b.color
            ));
        }

        /**
         * Performs one step of the Runge-Kutta 4th Order numerical integration.
         */
        function rk4Step() {
            if (bodies.length < 2) return;

            const dt = parseFloat(timeStepInput.value);
            const dt_half = dt * 0.5;

            // K1: derivatives at t
            let k1 = calculateDerivatives(bodies);

            // K2: derivatives at t + dt/2, using k1 to estimate state
            let bodies_k2 = cloneBodies(bodies);
            for (let i = 0; i < bodies.length; i++) {
                bodies_k2[i].pos.x = bodies[i].pos.x + k1[i].dPos.x * dt_half;
                bodies_k2[i].pos.y = bodies[i].pos.y + k1[i].dPos.y * dt_half;
                bodies_k2[i].vel.x = bodies[i].vel.x + k1[i].dVel.x * dt_half;
                bodies_k2[i].vel.y = bodies[i].vel.y + k1[i].dVel.y * dt_half;
            }
            let k2 = calculateDerivatives(bodies_k2);

            // K3: derivatives at t + dt/2, using k2 to estimate state
            let bodies_k3 = cloneBodies(bodies);
            for (let i = 0; i < bodies.length; i++) {
                bodies_k3[i].pos.x = bodies[i].pos.x + k2[i].dPos.x * dt_half;
                bodies_k3[i].pos.y = bodies[i].pos.y + k2[i].dPos.y * dt_half;
                bodies_k3[i].vel.x = bodies[i].vel.x + k2[i].dVel.x * dt_half;
                bodies_k3[i].vel.y = bodies[i].vel.y + k2[i].dVel.y * dt_half;
            }
            let k3 = calculateDerivatives(bodies_k3);

            // K4: derivatives at t + dt, using k3 to estimate state
            let bodies_k4 = cloneBodies(bodies);
            for (let i = 0; i < bodies.length; i++) {
                bodies_k4[i].pos.x = bodies[i].pos.x + k3[i].dPos.x * dt;
                bodies_k4[i].pos.y = bodies[i].pos.y + k3[i].dPos.y * dt;
                bodies_k4[i].vel.x = bodies[i].vel.x + k3[i].dVel.x * dt;
                bodies_k4[i].vel.y = bodies[i].vel.y + k3[i].dVel.y * dt;
            }
            let k4 = calculateDerivatives(bodies_k4);

            // Final Update: Weighted average of the four estimates
            const one_sixth = 1.0 / 6.0;
            for (let i = 0; i < bodies.length; i++) {
                const b = bodies[i];

                // Position update: y(t+dt) = y(t) + dt/6 * (k1 + 2k2 + 2k3 + k4)
                b.pos.x += dt * one_sixth * (k1[i].dPos.x + 2 * k2[i].dPos.x + 2 * k3[i].dPos.x + k4[i].dPos.x);
                b.pos.y += dt * one_sixth * (k1[i].dPos.y + 2 * k2[i].dPos.y + 2 * k3[i].dPos.y + k4[i].dPos.y);

                // Velocity update: y'(t+dt) = y'(t) + dt/6 * (k1' + 2k2' + 2k3' + k4')
                b.vel.x += dt * one_sixth * (k1[i].dVel.x + 2 * k2[i].dVel.x + 2 * k3[i].dVel.x + k4[i].dVel.x);
                b.vel.y += dt * one_sixth * (k1[i].dVel.y + 2 * k2[i].dVel.y + 2 * k3[i].dVel.y + k4[i].dVel.y);

                // Update trail
                b.trail.push({ x: b.pos.x, y: b.pos.y });
                if (b.trail.length > trailHistoryLength) {
                    b.trail.shift();
                }
            }
        }

        // --- DRAWING FUNCTIONS ---

        function drawBody(body) {
            // Convert simulation coordinates to canvas coordinates
            const screenX = body.pos.x + canvasCenter.x;
            const screenY = body.pos.y + canvasCenter.y;

            // Draw trail
            ctx.beginPath();
            if (body.trail.length > 1) {
                ctx.moveTo(body.trail[0].x + canvasCenter.x, body.trail[0].y + canvasCenter.y);
                for (let i = 1; i < body.trail.length; i++) {
                    // Fade the trail out
                    const opacity = i / body.trail.length * 0.3;
                    ctx.strokeStyle = body.color + Math.floor(opacity * 255).toString(16).padStart(2, '0');
                    ctx.lineTo(body.trail[i].x + canvasCenter.x, body.trail[i].y + canvasCenter.y);
                }
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Draw body itself
            ctx.beginPath();
            ctx.arc(screenX, screenY, body.radius, 0, Math.PI * 2, false);
            ctx.fillStyle = body.color;
            ctx.shadowBlur = 10; 
            ctx.shadowColor = body.color;
            ctx.fill();
            ctx.shadowBlur = 0; 
        }

        function drawCreationPreview() {
            if (!isDragging || !dragStartPos || !dragEndPos) return;

            // Adjust coordinates for control panel offset
            const startX = dragStartPos.x - 300; 
            const startY = dragStartPos.y;
            const endX = dragEndPos.x - 300;
            const endY = dragEndPos.y;

            const currentMass = parseFloat(massSlider.value);
            const currentRadius = Math.cbrt(currentMass) * 1.5 + 2;

            // 1. Draw projected body at click location
            ctx.beginPath();
            ctx.arc(startX, startY, currentRadius, 0, Math.PI * 2, false);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fill();

            // 2. Draw velocity vector (opposite direction of drag)
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            // Draw vector pointing in the direction of the intended velocity
            ctx.lineTo(startX - (endX - startX), startY - (endY - startY));
            ctx.strokeStyle = '#00ffaa';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function draw() {
            clearCanvas();
            drawCreationPreview();
            bodies.forEach(drawBody);
        }

        // --- Animation Loop ---
        let frameCount = 0;
        let lastFPSUpdateTime = 0;

        function gameLoop(timestamp) {
            if (!simRunning) return;

            // FPS Calculation
            frameCount++;
            if (timestamp - lastFPSUpdateTime >= 1000) {
                document.getElementById('fpsDisplay').textContent = frameCount;
                frameCount = 0;
                lastFPSUpdateTime = timestamp;
            }

            // Update physics
            rk4Step();
            
            // Redraw everything
            draw();

            requestAnimationFrame(gameLoop);
        }

        // --- INPUT HANDLERS ---

        function handleMouseDown(e) {
            // Check if click is on the canvas (x > 300, the control panel width)
            if (e.clientX < 300) return; 

            isDragging = true;
            dragStartPos = { x: e.clientX, y: e.clientY };
        }

        function handleMouseMove(e) {
            if (!isDragging) return;
            dragEndPos = { x: e.clientX, y: e.clientY };
            draw(); 
        }

        function handleMouseUp(e) {
            if (!dragStartPos) return;

            dragEndPos = { x: e.clientX, y: e.clientY };
            
            // Scaling factor for drag distance to velocity. Tweak this if speed is too fast/slow.
            const velocityScale = 0.007; 
            
            // Calculate velocity (opposite of drag direction, scaled)
            const velX = (dragStartPos.x - dragEndPos.x) * velocityScale;
            const velY = (dragStartPos.y - dragEndPos.y) * velocityScale;

            // Calculate position (relative to simulation center, adjusted for control panel offset)
            const simPosX = dragStartPos.x - 300 - canvasCenter.x;
            const simPosY = dragStartPos.y - canvasCenter.y;

            const mass = parseFloat(massSlider.value);

            bodies.push(new Body(
                mass,
                { x: simPosX, y: simPosY },
                { x: velX, y: velY }
            ));

            document.getElementById('bodyCount').textContent = bodies.length;

            isDragging = false;
            dragStartPos = null;
            dragEndPos = null;
        }

        // --- Event Listeners and Initialization ---

        function init() {
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); // Initial sizing

            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);

            document.getElementById('clearButton').addEventListener('click', () => {
                bodies = [];
                // Re-add the sun after clearing
                bodies.push(new Body(
                    10000, 
                    { x: 0, y: 0 },
                    { x: 0, y: 0 },
                    '#ffaa00' // Yellow/Orange Star
                ));
                document.getElementById('bodyCount').textContent = bodies.length;
                draw();
            });

            // Update labels when sliders move
            massSlider.addEventListener('input', (e) => {
                currentMassDisplay.textContent = `Mass: ${e.target.value}`;
            });
            gConstantInput.addEventListener('input', (e) => {
                currentGDisplay.textContent = `G: ${e.target.value}`;
            });


            // Initial body: The Sun/Star
            bodies.push(new Body(
                10000, // Large Mass
                { x: 0, y: 0 },
                { x: 0, y: 0 },
                '#ffaa00' 
            ));
            document.getElementById('bodyCount').textContent = bodies.length;

            requestAnimationFrame(gameLoop);
        }

        init();
    </script>

</body>
</html>



