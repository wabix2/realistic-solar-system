<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D RK4 N-Body Simulator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            background-color: #1a1a2e; /* Dark space background */
            color: #ffffff;
            font-family: Arial, sans-serif;
        }
        #controls {
            width: 280px;
            padding: 20px;
            background-color: #1e1e3f;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
        }
        #simCanvas {
            flex-grow: 1;
            cursor: crosshair;
        }
        .control-group {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #3a3a6e;
            border-radius: 5px;
        }
        button {
            background-color: #4a4a9e;
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #5a5ac8;
        }
    </style>
</head>
<body>

    <div id="controls">
        <h1 style="color: #ffcc00; font-size: 1.5rem; margin-bottom: 20px;">N-Body Controls</h1>

        <div class="control-group">
            <label for="massSlider" style="display: block; margin-bottom: 5px;">New Body Mass:</label>
            <input type="range" id="massSlider" min="5" max="500" value="50" step="5" style="width: 100%;">
            <p style="text-align: center; font-weight: bold;"><span id="currentMass">Mass: 50</span></p>
        </div>

        <div class="control-group">
            <p style="margin-bottom: 10px;">**Creation Method:** Click and drag on the canvas. Drag distance determines initial velocity.</p>
            <button id="clearButton">Clear All Bodies</button>
        </div>

        <div class="control-group">
            <label for="timeStep" style="display: block; margin-bottom: 5px;">Time Step ($\Delta t$):</label>
            <input type="number" id="timeStep" value="0.01" step="0.001" min="0.001" max="0.1" style="width: 100%; padding: 5px; background: #3a3a6e; border: 1px solid #5a5ac8; color: white;">
        </div>

        <div style="margin-top: 30px;">
            <p style="color: #00ffaa; font-weight: bold;">Simulation Status:</p>
            <p>Bodies: <span id="bodyCount">0</span></p>
            <p>FPS: <span id="fpsDisplay">0</span></p>
            <p style="margin-top: 10px; font-size: 0.8rem; color: #aaa;">Physics Core: RK4</p>
        </div>
    </div>

    <canvas id="simCanvas"></canvas>

    <script>
        // --- Setup ---
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        let bodies = [];
        let G = 0.000000000066743; // Gravitational Constant (Can be adjusted for visualization scale)
        let simRunning = true;

        // Display/Input Variables
        let canvasCenter = { x: 0, y: 0 };
        let dragStartPos = null;
        let dragEndPos = null;
        let dragVelocity = null;
        let isDragging = false;
        let trailHistoryLength = 400; // Length of the path trail

        // Get initial values from controls
        const massSlider = document.getElementById('massSlider');
        const timeStepInput = document.getElementById('timeStep');
        const currentMassDisplay = document.getElementById('currentMass');

        // --- Celestial Body Class (2D) ---
        class Body {
            constructor(mass, pos, vel, color = null) {
                this.mass = mass;
                this.pos = { x: pos.x, y: pos.y }; // Position (x, y)
                this.vel = { x: vel.x, y: vel.y }; // Velocity (vx, vy)
                this.acc = { x: 0, y: 0 };         // Acceleration (ax, ay)
                this.radius = Math.cbrt(mass) * 0.5 + 2; // Size proportional to mass
                this.color = color || '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
                this.trail = [];
            }
        }

        // --- Utility Functions ---

        function resizeCanvas() {
            canvas.width = window.innerWidth - 280; // Subtract control panel width
            canvas.height = window.innerHeight;
            canvasCenter.x = canvas.width / 2;
            canvasCenter.y = canvas.height / 2;
            // Redraw everything after resize
            draw();
        }

        function clearCanvas() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function getDistanceSq(b1, b2) {
            const dx = b2.pos.x - b1.pos.x;
            const dy = b2.pos.y - b1.pos.y;
            return dx * dx + dy * dy;
        }

        function getDirectionVector(b1, b2) {
            return {
                x: b2.pos.x - b1.pos.x,
                y: b2.pos.y - b1.pos.y
            };
        }

        function normalizeVector(v) {
            const magnitude = Math.sqrt(v.x * v.x + v.y * v.y);
            return {
                x: v.x / magnitude,
                y: v.y / magnitude
            };
        }

        // --- PHYSICS CORE: RK4 INTEGRATION ---

        /**
         * Calculates the derivatives (velocities and accelerations) for a set of bodies.
         * The result is the current velocity (dx/dt) and the acceleration (dv/dt).
         * @param {Array<Body>} currentBodies - The bodies at the current (or intermediate) state.
         * @returns {Array<{dPos: {x, y}, dVel: {x, y}}>} The derivatives (k-value).
         */
        function calculateDerivatives(currentBodies) {
            const derivatives = currentBodies.map(b => ({
                dPos: { x: b.vel.x, y: b.vel.y },
                dVel: { x: 0, y: 0 }
            }));

            // Calculate accelerations (dv/dt)
            for (let i = 0; i < currentBodies.length; i++) {
                const b_i = currentBodies[i];
                let accX = 0;
                let accY = 0;

                for (let j = 0; j < currentBodies.length; j++) {
                    if (i === j) continue; // Skip self-interaction

                    const b_j = currentBodies[j];
                    const dir = getDirectionVector(b_i, b_j);
                    const r_sq = getDistanceSq(b_i, b_j);

                    // Add a small constant to prevent division by zero during close encounters
                    const safe_r_sq = Math.max(r_sq, 1);

                    // F = G * (m1 * m2) / r^2
                    // a_i = F / m_i = G * m_j / r^2
                    const magnitude = (G * b_j.mass) / safe_r_sq;
                    const unitDir = normalizeVector(dir);

                    accX += magnitude * unitDir.x;
                    accY += magnitude * unitDir.y;
                }
                derivatives[i].dVel.x = accX;
                derivatives[i].dVel.y = accY;
            }
            return derivatives;
        }

        /**
         * Clones the bodies array for use in intermediate RK4 calculations.
         */
        function cloneBodies(sourceBodies) {
            return sourceBodies.map(b => new Body(
                b.mass,
                { x: b.pos.x, y: b.pos.y },
                { x: b.vel.x, y: b.vel.y },
                b.color
            ));
        }

        /**
         * Performs one step of the Runge-Kutta 4th Order numerical integration.
         */
        function rk4Step() {
            if (bodies.length < 2) return;

            const dt = parseFloat(timeStepInput.value);
            const dt_half = dt * 0.5;

            // K1
            let k1 = calculateDerivatives(bodies);

            // K2
            let bodies_k2 = cloneBodies(bodies);
            for (let i = 0; i < bodies.length; i++) {
                bodies_k2[i].pos.x = bodies[i].pos.x + k1[i].dPos.x * dt_half;
                bodies_k2[i].pos.y = bodies[i].pos.y + k1[i].dPos.y * dt_half;
                bodies_k2[i].vel.x = bodies[i].vel.x + k1[i].dVel.x * dt_half;
                bodies_k2[i].vel.y = bodies[i].vel.y + k1[i].dVel.y * dt_half;
            }
            let k2 = calculateDerivatives(bodies_k2);

            // K3
            let bodies_k3 = cloneBodies(bodies);
            for (let i = 0; i < bodies.length; i++) {
                bodies_k3[i].pos.x = bodies[i].pos.x + k2[i].dPos.x * dt_half;
                bodies_k3[i].pos.y = bodies[i].pos.y + k2[i].dPos.y * dt_half;
                bodies_k3[i].vel.x = bodies[i].vel.x + k2[i].dVel.x * dt_half;
                bodies_k3[i].vel.y = bodies[i].vel.y + k2[i].dVel.y * dt_half;
            }
            let k3 = calculateDerivatives(bodies_k3);

            // K4
            let bodies_k4 = cloneBodies(bodies);
            for (let i = 0; i < bodies.length; i++) {
                bodies_k4[i].pos.x = bodies[i].pos.x + k3[i].dPos.x * dt;
                bodies_k4[i].pos.y = bodies[i].pos.y + k3[i].dPos.y * dt;
                bodies_k4[i].vel.x = bodies[i].vel.x + k3[i].dVel.x * dt;
                bodies_k4[i].vel.y = bodies[i].vel.y + k3[i].dVel.y * dt;
            }
            let k4 = calculateDerivatives(bodies_k4);

            // Final Update
            const one_sixth = 1.0 / 6.0;
            for (let i = 0; i < bodies.length; i++) {
                const b = bodies[i];

                // Position update: pos += dt/6 * (k1.dPos + 2*k2.dPos + 2*k3.dPos + k4.dPos)
                b.pos.x += dt * one_sixth * (k1[i].dPos.x + 2 * k2[i].dPos.x + 2 * k3[i].dPos.x + k4[i].dPos.x);
                b.pos.y += dt * one_sixth * (k1[i].dPos.y + 2 * k2[i].dPos.y + 2 * k3[i].dPos.y + k4[i].dPos.y);

                // Velocity update: vel += dt/6 * (k1.dVel + 2*k2.dVel + 2*k3.dVel + k4.dVel)
                b.vel.x += dt * one_sixth * (k1[i].dVel.x + 2 * k2[i].dVel.x + 2 * k3[i].dVel.x + k4[i].dVel.x);
                b.vel.y += dt * one_sixth * (k1[i].dVel.y + 2 * k2[i].dVel.y + 2 * k3[i].dVel.y + k4[i].dVel.y);

                // Update trail
                b.trail.push({ x: b.pos.x, y: b.pos.y });
                if (b.trail.length > trailHistoryLength) {
                    b.trail.shift();
                }
            }
        }

        // --- DRAWING FUNCTIONS ---

        function drawBody(body) {
            // Convert simulation coordinates to canvas coordinates
            const screenX = body.pos.x + canvasCenter.x;
            const screenY = body.pos.y + canvasCenter.y;

            // Draw trail
            ctx.beginPath();
            if (body.trail.length > 1) {
                ctx.moveTo(body.trail[0].x + canvasCenter.x, body.trail[0].y + canvasCenter.y);
                for (let i = 1; i < body.trail.length; i++) {
                    // Create fading effect by adjusting opacity based on trail age
                    const opacity = i / body.trail.length * 0.4;
                    ctx.strokeStyle = body.color + Math.floor(opacity * 255).toString(16).padStart(2, '0');
                    ctx.lineTo(body.trail[i].x + canvasCenter.x, body.trail[i].y + canvasCenter.y);
                }
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            // Draw body itself
            ctx.beginPath();
            ctx.arc(screenX, screenY, body.radius, 0, Math.PI * 2, false);
            ctx.fillStyle = body.color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = body.color;
            ctx.fill();
            ctx.shadowBlur = 0; // Reset shadow
        }

        function drawCreationPreview() {
            if (!isDragging || !dragStartPos || !dragEndPos) return;

            const startX = dragStartPos.x - 280; // Adjust for control panel
            const startY = dragStartPos.y;
            const endX = dragEndPos.x - 280;
            const endY = dragEndPos.y;

            const currentMass = parseFloat(massSlider.value);
            const currentRadius = Math.cbrt(currentMass) * 0.5 + 2;

            // Draw projected body at click location
            ctx.beginPath();
            ctx.arc(startX, startY, currentRadius, 0, Math.PI * 2, false);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fill();

            // Draw velocity vector (opposite direction of drag)
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(startX - (endX - startX), startY - (endY - startY));
            ctx.strokeStyle = '#00ffaa';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function draw() {
            clearCanvas();
            drawCreationPreview();
            bodies.forEach(drawBody);
        }

        // --- Animation Loop ---
        let lastTime = 0;
        let frameCount = 0;
        let lastFPSUpdateTime = 0;

        function gameLoop(timestamp) {
            if (!simRunning) return;

            // FPS Calculation
            frameCount++;
            if (timestamp - lastFPSUpdateTime >= 1000) {
                document.getElementById('fpsDisplay').textContent = frameCount;
                frameCount = 0;
                lastFPSUpdateTime = timestamp;
            }

            // Update physics
            rk4Step();
            
            // Redraw everything
            draw();

            requestAnimationFrame(gameLoop);
        }

        // --- INPUT HANDLERS ---

        function handleMouseDown(e) {
            isDragging = true;
            dragStartPos = { x: e.clientX, y: e.clientY };
        }

        function handleMouseMove(e) {
            if (!isDragging) return;
            dragEndPos = { x: e.clientX, y: e.clientY };
            // Request redraw to update velocity preview line
            draw(); 
        }

        function handleMouseUp(e) {
            if (!dragStartPos) return;

            dragEndPos = { x: e.clientX, y: e.clientY };
            const velocityScale = 0.005; // Adjust sensitivity
            
            // Calculate velocity (opposite of drag direction)
            const velX = (dragStartPos.x - dragEndPos.x) * velocityScale;
            const velY = (dragStartPos.y - dragEndPos.y) * velocityScale;

            // Calculate position (relative to simulation center, adjusted for control panel offset)
            const simPosX = dragStartPos.x - 280 - canvasCenter.x;
            const simPosY = dragStartPos.y - canvasCenter.y;

            const mass = parseFloat(massSlider.value);

            bodies.push(new Body(
                mass,
                { x: simPosX, y: simPosY },
                { x: velX, y: velY }
            ));

            document.getElementById('bodyCount').textContent = bodies.length;

            isDragging = false;
            dragStartPos = null;
            dragEndPos = null;
        }

        // --- Event Listeners and Initialization ---

        function init() {
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); // Initial sizing

            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);

            document.getElementById('clearButton').addEventListener('click', () => {
                bodies = [];
                document.getElementById('bodyCount').textContent = 0;
                draw();
            });

            massSlider.addEventListener('input', (e) => {
                currentMassDisplay.textContent = `Mass: ${e.target.value}`;
            });

            // Start with a large central body (Sun/Star)
            bodies.push(new Body(
                5000,
                { x: 0, y: 0 },
                { x: 0, y: 0 },
                '#ffaa00' // Yellow/Orange Star
            ));
            document.getElementById('bodyCount').textContent = bodies.length;

            requestAnimationFrame(gameLoop);
        }

        init();
    </script>

</body>
</html>


