<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RK4 Planetary N-Body Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Apply the Inter font globally */
        body { font-family: 'Inter', sans-serif; }
        
        /* Ensure the canvas is responsive and centered */
        #simulation-canvas {
            background-color: #030712; /* Dark background matches UI */
            cursor: crosshair;
            display: block;
            border-radius: 0.75rem; /* rounded-xl */
        }
    </style>
</head>
<body class="min-h-screen bg-gray-900 text-gray-100 p-4 md:p-8">

    <header class="text-center mb-8">
        <h1 class="text-4xl font-extrabold text-yellow-400">
            Planetary RK4 Simulation
        </h1>
        <p class="text-gray-400 text-sm mt-1">
            High-accuracy N-Body Simulation using Runge-Kutta 4th Order Integration.
        </p>
    </header>

    <div class="flex flex-col lg:flex-row gap-6 max-w-7xl mx-auto">
        
        <div id="controls-panel" class="lg:w-1/4 p-4 bg-gray-800 rounded-xl shadow-lg h-fit">
            <h2 class="text-xl font-semibold text-indigo-400 mb-4 border-b border-gray-700 pb-2">
                Controls
            </h2>

            <div class="space-y-4">
                <button
                    id="toggle-sim-btn"
                    class="w-full py-3 rounded-lg font-bold transition duration-200 shadow-md bg-green-600 hover:bg-green-700 text-white"
                >
                    Start Simulation
                </button>

                <button
                    id="reset-sim-btn"
                    class="w-full py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg transition duration-200 shadow-md"
                >
                    Reset System
                </button>

                <div>
                    <label for="dt-input" class="text-sm font-medium text-gray-300 block mb-1">
                        Time Step ($\Delta t$):
                    </label>
                    <input
                        id="dt-input"
                        type="number"
                        value="0.1"
                        step="0.005"
                        min="0.001"
                        class="w-full p-2 bg-gray-700 border border-gray-600 rounded-md text-sm text-white"
                    />
                    <p class="text-xs text-gray-400 mt-1">
                        Smaller $\Delta t$ = Higher Accuracy (but slower). Recommended: 0.1
                    </p>
                </div>

                <div>
                    <label for="G-input" class="text-sm font-medium text-gray-300 block mb-1">
                        Gravity Constant (G):
                    </label>
                    <input
                        id="G-input"
                        type="number"
                        value="0.001"
                        step="0.0001"
                        min="0.0001"
                        class="w-full p-2 bg-gray-700 border border-gray-600 rounded-md text-sm text-white"
                    />
                </div>
            </div>
        </div>

        <div class="lg:w-3/4 bg-gray-800 rounded-xl shadow-lg p-1 flex justify-center items-center relative">
            <canvas
                id="simulation-canvas"
                width="800"
                height="600"
                class="rounded-lg w-full max-w-full h-auto"
                style="aspect-ratio: 800/600;"
            ></canvas>
            <div id="click-message" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center bg-gray-900 bg-opacity-70 p-4 rounded-lg">
                <p class="text-lg font-semibold text-yellow-300">
                    Click on the canvas to add a new celestial body!
                </p>
                <p class="text-sm text-gray-400 mt-1">
                    Note: Click adds body with random mass and small initial velocity.
                </p>
            </div>
        </div>
    </div>
    
    <div class="max-w-7xl mx-auto mt-6 p-4 bg-gray-800 rounded-xl shadow-lg">
        <h2 class="text-xl font-semibold text-green-400 mb-2">
            Current Bodies (<span id="body-count">0</span>)
        </h2>
        <div id="bodies-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
            </div>
    </div>

    <script>
        // --- CONSTANTS ---
        const INITIAL_G = 0.001;
        const INITIAL_DT = 0.1;
        const MAX_HISTORY = 400;
        const SCALE = 5; // Pixels per unit distance

        // --- GLOBAL STATE ---
        let bodies = [];
        let isRunning = false;
        let dt = INITIAL_DT;
        let G = INITIAL_G;
        let nextId = 0;
        let animationFrameId = null;

        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('simulation-canvas');
        const ctx = canvas.getContext('2d');
        const toggleBtn = document.getElementById('toggle-sim-btn');
        const resetBtn = document.getElementById('reset-sim-btn');
        const dtInput = document.getElementById('dt-input');
        const gInput = document.getElementById('G-input');
        const bodiesListDiv = document.getElementById('bodies-list');
        const bodyCountSpan = document.getElementById('body-count');
        const clickMessage = document.getElementById('click-message');

        // --- CORE PHYSICS LOGIC (RK4 Implementation) ---

        const calculateAcceleration = (bodyIndex, currentBodies, G) => {
            const bodyA = currentBodies[bodyIndex];
            let accX = 0;
            let accY = 0;

            for (let j = 0; j < currentBodies.length; j++) {
                if (bodyIndex === j) continue;

                const bodyB = currentBodies[j];
                
                const dx = bodyB.pos.x - bodyA.pos.x;
                const dy = bodyB.pos.y - bodyA.pos.y;
                
                const distanceSquared = dx * dx + dy * dy;
                const distance = Math.sqrt(distanceSquared);

                if (distance < bodyA.radius * 0.1 || distance < bodyB.radius * 0.1) continue; // Prevent singularity at 0 distance

                // F = G * m1 * m2 / r^2
                const forceMagnitude = (G * bodyA.mass * bodyB.mass) / distanceSquared;
                
                // Acceleration magnitude: a = F / m_A
                const accelerationMagnitude = forceMagnitude / bodyA.mass;

                // Resolve vector components (a_x = a * dx/r)
                const accComponent = accelerationMagnitude / distance;
                
                accX += accComponent * dx;
                accY += accComponent * dy;
            }

            return { x: accX, y: accY };
        };

        const rk4Step = (prevBodies, dt, G) => {
            if (prevBodies.length < 2) return prevBodies;
            
            const calculateRate = (tempBodies) => {
                return tempBodies.map((body, i) => {
                    const acc = calculateAcceleration(i, tempBodies, G);
                    return { vel: body.vel, acc: acc };
                });
            };

            const applyOffset = (rates, factor, prevBodies) => {
                return prevBodies.map((body, i) => {
                    return {
                        ...body,
                        pos: {
                            x: body.pos.x + rates[i].vel.x * factor,
                            y: body.pos.y + rates[i].vel.y * factor
                        },
                        vel: {
                            x: body.vel.x + rates[i].acc.x * factor,
                            y: body.vel.y + rates[i].acc.y * factor
                        },
                    };
                });
            };

            // K1 = f(S)
            const k1_rates = calculateRate(prevBodies);
            
            // K2 = f(S + dt/2 * K1)
            const k2_state = applyOffset(k1_rates, dt / 2, prevBodies);
            const k2_rates = calculateRate(k2_state);
            
            // K3 = f(S + dt/2 * K2)
            const k3_state = applyOffset(k2_rates, dt / 2, prevBodies);
            const k3_rates = calculateRate(k3_state);
            
            // K4 = f(S + dt * K3)
            const k4_state = applyOffset(k3_rates, dt, prevBodies);
            const k4_rates = calculateRate(k4_state);

            // Final update: S_new = S_old + dt/6 * (K1 + 2*K2 + 2*K3 + K4)
            return prevBodies.map((body, i) => {
                const avgVelX = (k1_rates[i].vel.x + 2 * k2_rates[i].vel.x + 2 * k3_rates[i].vel.x + k4_rates[i].vel.x) / 6;
                const avgVelY = (k1_rates[i].vel.y + 2 * k2_rates[i].vel.y + 2 * k3_rates[i].vel.y + k4_rates[i].vel.y) / 6;
                const avgAccX = (k1_rates[i].acc.x + 2 * k2_rates[i].acc.x + 2 * k3_rates[i].acc.x + k4_rates[i].acc.x) / 6;
                const avgAccY = (k1_rates[i].acc.y + 2 * k2_rates[i].acc.y + 2 * k3_rates[i].acc.y + k4_rates[i].acc.y) / 6;

                const newPos = {
                    x: body.pos.x + avgVelX * dt,
                    y: body.pos.y + avgVelY * dt
                };
                const newVel = {
                    x: body.vel.x + avgAccX * dt,
                    y: body.vel.y + avgAccY * dt
                };

                const newHistory = [...body.history, newPos];
                if (newHistory.length > MAX_HISTORY) {
                    newHistory.shift();
                }

                return {
                    ...body,
                    pos: newPos,
                    vel: newVel,
                    history: newHistory
                };
            });
        };

        // --- RENDERING & UI UPDATE ---

        const simToCanvas = (x, y) => ({
            x: canvas.width / 2 + x * SCALE,
            y: canvas.height / 2 - y * SCALE // Flip Y
        });

        const draw = (currentBodies) => {
            if (!ctx) return;

            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = '#030712';
            ctx.fillRect(0, 0, width, height);

            currentBodies.forEach(body => {
                const pixelPos = simToCanvas(body.pos.x, body.pos.y);

                // 1. Draw Trajectory History
                if (body.history.length > 1) {
                    ctx.beginPath();
                    ctx.strokeStyle = body.color + '40'; // Semi-transparent trail
                    ctx.lineWidth = 1;
                    
                    const startPoint = simToCanvas(body.history[0].x, body.history[0].y);
                    ctx.moveTo(startPoint.x, startPoint.y);

                    for (let i = 1; i < body.history.length; i++) {
                        const histPos = simToCanvas(body.history[i].x, body.history[i].y);
                        ctx.lineTo(histPos.x, histPos.y);
                    }
                    ctx.stroke();
                }

                // 2. Draw the Body
                ctx.beginPath();
                ctx.arc(pixelPos.x, pixelPos.y, body.radius, 0, Math.PI * 2);
                ctx.fillStyle = body.color;
                ctx.shadowColor = body.color;
                ctx.shadowBlur = body.radius * 2;
                ctx.fill();
                ctx.shadowBlur = 0; // Reset shadow
            });
        };

        const updateBodyList = () => {
            bodyCountSpan.textContent = bodies.length;
            bodiesListDiv.innerHTML = bodies.map(body => `
                <div class="p-3 bg-gray-700 rounded-lg text-xs border-l-4" style="border-color: ${body.color};">
                    <span class="font-bold text-gray-100">Body ${body.id === 0 ? 'Star' : body.id}</span>
                    <ul class="list-disc pl-4 mt-1 space-y-0.5">
                        <li>Mass: ${body.mass.toFixed(1)}</li>
                        <li>Pos: (${body.pos.x.toFixed(1)}, ${body.pos.y.toFixed(1)})</li>
                        <li>Vel: (${body.vel.x.toFixed(2)}, ${body.vel.y.toFixed(2)})</li>
                    </ul>
                </div>
            `).join('');
        };

        const updateControls = () => {
            if (isRunning) {
                toggleBtn.textContent = 'Pause Simulation';
                toggleBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
                toggleBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600', 'text-gray-900');
                clickMessage.classList.add('hidden');
                canvas.style.cursor = 'default';
            } else {
                toggleBtn.textContent = 'Start Simulation';
                toggleBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600', 'text-gray-900');
                toggleBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                clickMessage.classList.remove('hidden');
                canvas.style.cursor = 'crosshair';
            }
        };

        // --- GAME LOOP & HANDLERS ---

        const gameLoop = () => {
            if (isRunning && bodies.length >= 2) {
                bodies = rk4Step(bodies, dt, G);
                updateBodyList();
            }
            draw(bodies);
            animationFrameId = requestAnimationFrame(gameLoop);
        };

        const initSimulation = () => {
            // Initial Demo Setup (Sun and orbiting planet)
            const initialBodies = [
                {
                    id: 0, mass: 2000, radius: 10, color: '#FFD700', // Star
                    pos: { x: 0, y: 0 }, vel: { x: 0, y: 0 }, history: [{ x: 0, y: 0 }]
                },
                {
                    id: 1, mass: 100, radius: 4, color: '#00BFFF', // Planet
                    pos: { x: 100, y: 0 }, vel: { x: 0, y: 0 }, history: [{ x: 100, y: 0 }]
                },
            ];
            
            // Calculate initial velocity for a stable circular orbit (v = sqrt(G*M/r))
            const r = 100;
            const starMass = initialBodies[0].mass;
            const v = Math.sqrt(INITIAL_G * starMass / r);
            initialBodies[1].vel.y = v; 
            
            bodies = initialBodies;
            nextId = initialBodies.length;
            dt = INITIAL_DT;
            G = INITIAL_G;
            dtInput.value = INITIAL_DT;
            gInput.value = INITIAL_G;
            isRunning = false;

            updateControls();
            updateBodyList();
            draw(bodies); // Initial draw
        };

        const toggleSimulation = () => {
            isRunning = !isRunning;
            updateControls();
        };

        const handleCanvasClick = (event) => {
            if (isRunning) return;

            const rect = canvas.getBoundingClientRect();
            
            // Convert screen pixels to simulation coordinates
            const pixelX = event.clientX - rect.left;
            const pixelY = event.clientY - rect.top;
            const simX = (pixelX - canvas.width / 2) / SCALE;
            const simY = (canvas.height / 2 - pixelY) / SCALE; // Remember Y is flipped in canvas

            // Create new body
            const newBody = {
                id: nextId,
                mass: Math.random() * 50 + 50, // Mass between 50 and 100
                radius: Math.random() * 2 + 3, // Radius between 3 and 5
                color: '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'),
                pos: { x: simX, y: simY },
                // Give it a small, random velocity initially
                vel: { x: (Math.random() - 0.5) * 5, y: (Math.random() - 0.5) * 5 },
                history: [{ x: simX, y: simY }]
            };
            
            bodies.push(newBody);
            nextId++;
            updateBodyList();
            draw(bodies);
        };

        // --- EVENT LISTENERS ---

        toggleBtn.addEventListener('click', toggleSimulation);
        resetBtn.addEventListener('click', initSimulation);
        canvas.addEventListener('click', handleCanvasClick);

        dtInput.addEventListener('input', (e) => {
            dt = parseFloat(e.target.value) || 0;
        });

        gInput.addEventListener('input', (e) => {
            G = parseFloat(e.target.value) || 0;
        });
        
        // --- INITIALIZATION ---
        window.onload = function () {
            // Match canvas width to container size for responsiveness
            const container = canvas.parentElement;
            if (container) {
                canvas.width = container.clientWidth - 2; // -2 for padding safety
                canvas.height = (canvas.width / 800) * 600; // Maintain 800:600 aspect ratio
            }

            initSimulation();
            gameLoop();
        }

    </script>
</body>
</html>
```eof
    
